"""Urban Boundary Layer Observation Data ProcessingScript name:    Spectral AnalysisPath:           ~/bin/spectral.pyDescription:    Perform spectral analysis on data collected by the flux tower atop the Marshak Building at The City College of New York."""import matplotlib.pyplot as plt, numpy as np, os, pandas as pdfrom scipy.fft import fft, fftfreqdef processor(data, intv, param):    '''    Perform spectral analysis on a DataFrame given a time interval and parameter.    Parameters    ----------    data : Pandas DataFrame        DataFrame constructed using data from Marshak flux tower data.    intv : str        Time interval to chunk DataFrame into. See https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects for reference on how to format this string. Default value of '30T', or 30 minutes, provided.    param : str        Column header string of parameter to analyze.    Returns    -------    freq : NumPy array        Array of averaged spectral analysis frequencies.    arr : NumPy array        Array of averaged spectral analysis power densities.    '''        # Group data based on given interval    groups = data.groupby(pd.Grouper(freq='30T'))    # Define size of empty Fourier matrix    size = max([len(group) for key, group in groups]) // 2    # Initialize lists for future averaging for frequency and Fourier transform data    freqs, arrs, N, T = np.empty(((size, 0)), float), np.empty((size, 0), float), np.nan, np.nan    # Iterate through groups and perform transforms    for key, group in groups:        # Initialize nan arrays with uniform size. Necessary for averaging.        freq, arr = np.full(size, np.nan), np.full(size, np.nan)        # Define number of samples in group        N = len(group)        # Define average time difference between each sample        T = np.nanmean(np.diff(group.timestamp)) / np.timedelta64(1, 's')        # Calculate frequency domain        freq_ = fftfreq(N, T)        # Place frequencies into nan array, filter out negatives        freq[0:len(freq_[freq_>=0])] = freq_[freq_>=0]        # Calculate fast Fourier transform array for the given parameter        arr_ = np.abs(fft(group[param].to_numpy())[freq_>=0])**2        # Place frequencies into nan array        arr[0:len(arr_)] = arr_        # Append data to respective lists        freqs = np.column_stack((freqs, freq))        arrs = np.column_stack((arrs, arr))            # Obtain averaged data    freq = np.nanmean(freqs, axis=1)    arr = np.nanmean(freqs*arrs, axis=1)        # Define number of frequency bands    N_bands = 16    # Define frequency bands    freq_bands = np.logspace(np.log10(sorted(freq)[1]), np.log10(np.nanmax(freq)), N_bands)    freq_bands = np.insert(freq_bands, 0, 0)    # Average data over defined frequency bands    freq_avgd = [np.nanmean(freq[(freq >= freq_bands[i]) & (freq < freq_bands[i+1])])                  for i in np.arange(0, len(freq_bands)-1)]    arr_avgd = [np.nanmean(arr[(freq >= freq_bands[i]) & (freq < freq_bands[i+1])])                 for i in np.arange(0, len(freq_bands)-1)]        # Test plot    fig, ax = plt.subplots(dpi=300)    im = ax.loglog(freq, arr)    im_avgd = ax.loglog(freq_avgd, arr_avgd)        return freq, arr    if __name__ == '__main__':    print('Troubleshoot this unit here.')            